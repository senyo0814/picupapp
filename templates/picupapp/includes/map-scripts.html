<script>
    let markers = [];
    let map;
    let clusteredBounds = null;

    const globalUserColorMap = {};
    const allColors = [
        '#e74c3c', '#3498db', '#2ecc71', '#9b59b6',
        '#f1c40f', '#e67e22', '#1abc9c', '#34495e',
        '#d35400', '#7f8c8d', '#8e44ad', '#16a085'
    ];
    let colorIndex = 0;
    let activeUsers = new Set();

    function highlightMatch(text, keyword) {
        if (!keyword) return text;
        const regex = new RegExp(`(${keyword})`, 'ig');
        return text.replace(regex, '<mark class="bg-yellow-300 dark:bg-yellow-500 text-black dark:text-white">$1</mark>');
    }

    function updateCountryPhotoCount(filteredPhotos, selectedCountry) {
        const count = filteredPhotos.length;
        const nameEl = document.getElementById('selectedCountryName');
        const countEl = document.getElementById('photoCountForCountry');
        const suffixEl = document.getElementById('pluralSuffix');

        if (nameEl && countEl && suffixEl) {
            nameEl.textContent = selectedCountry || 'All Countries';
            countEl.textContent = count;
            suffixEl.textContent = count === 1 ? '' : 's';
        }
    }

    const clusterRenderer = {
        render: ({ count, position }) => {
            const isDark = document.documentElement.classList.contains("dark");
            const fillColor = isDark ? "#facc15" : "#2563eb";
            const textColor = isDark ? "#000000" : "#ffffff";

            return new google.maps.Marker({
                position,
                icon: {
                    url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`
                        <svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="25" cy="25" r="22" fill="${fillColor}" stroke="white" stroke-width="4"/>
                            <text x="50%" y="50%" text-anchor="middle" dy=".3em" font-size="16" font-family="Arial" fill="${textColor}">${count}</text>
                        </svg>
                    `)}`,
                    scaledSize: new google.maps.Size(50, 50),
                },
                zIndex: google.maps.Marker.MAX_ZINDEX + count,
            });
        }
    };

    function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
            zoom: 2,
            center: { lat: 37.7749, lng: -122.4194 }
        });

        renderMarkers();
        populateCountryDropdown();

        document.getElementById('legendSearch').addEventListener('input', () => {
            const keyword = document.getElementById('legendSearch').value.toLowerCase();
            activeUsers = new Set();
            allPhotos.forEach(p => {
                const user = (p.user || 'Unknown');
                if (user.toLowerCase().includes(keyword)) {
                    activeUsers.add(user);
                }
            });

            document.querySelector('input[name="legendFilter"][value="all"]').checked = false;
            renderMarkers();
        });
    }

    function renderMarkers() {
        markers.forEach(m => m.setMap(null));
        markers = [];
        clusteredBounds = null;

        const bounds = new google.maps.LatLngBounds();
        const legendList = document.getElementById('legendList');
        legendList.querySelectorAll('button[data-user]').forEach(el => el.parentElement.remove());

        const selectedCountry = document.getElementById('countryFilter')?.value || "";
        const filteredPhotos = allPhotos.filter(photo => {
            return (!selectedCountry || photo.country === selectedCountry) &&
                (!activeUsers.size || activeUsers.has(photo.user || 'Unknown')) &&
                photo.latitude && photo.longitude;
        });

        updateCountryPhotoCount(filteredPhotos, selectedCountry);

        const userMarkersMap = {};
        filteredPhotos.forEach(photo => {
            const user = photo.user || 'Unknown';

            if (!globalUserColorMap[user]) {
                globalUserColorMap[user] = allColors[colorIndex % allColors.length];
                colorIndex++;
            }

            if (!userMarkersMap[user]) {
                userMarkersMap[user] = [];
            }
            userMarkersMap[user].push(photo);
        });

        const createdMarkers = [];

        Object.entries(userMarkersMap).forEach(([user, photos]) => {
            const keyword = document.getElementById('legendSearch').value.toLowerCase();
            if (keyword && !user.toLowerCase().includes(keyword)) return;

            const color = globalUserColorMap[user];
            const isActive = activeUsers.has(user);

            const li = document.createElement('li');
            li.innerHTML = `
                <button data-user="${user}"
                    class="legend-btn px-2 flex items-center gap-2 text-sm text-gray-700 dark:text-gray-200 hover:text-blue-600 transition w-full text-left ${isActive ? 'bg-blue-100 text-blue-800 dark:bg-blue-600 dark:text-white font-semibold' : ''}">
                    <span class="inline-block w-3 h-3 rounded-full" style="background-color: ${color}"></span>
                    <span>${highlightMatch(user, keyword)}</span>
                </button>`;
            legendList.appendChild(li);

            photos.forEach(photo => {
                const pos = { lat: photo.latitude, lng: photo.longitude };
                const marker = new google.maps.Marker({
                    position: pos,
                    icon: {
                        url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`
                            <svg xmlns='http://www.w3.org/2000/svg' width='24' height='36' viewBox='0 0 24 36' fill='${color}'>
                                <path d='M12 0C7 0 3 4 3 9c0 6.5 9 18 9 18s9-11.5 9-18c0-5-4-9-9-9zM12 12.5c-2 0-3.5-1.5-3.5-3.5S10 5.5 12 5.5 15.5 7 15.5 9 14 12.5 12 12.5z'/>
                            </svg>`)}`,
                    }
                });

                const popup = `
                    <div class="text-sm text-gray-800 dark:text-white bg-white dark:bg-gray-800 p-2 rounded shadow">
                        <img src="${photo.image_url}" class="max-w-full max-h-[300px] object-contain mx-auto mb-2 rounded cursor-pointer" onclick="showFullscreenImage('${photo.image_url}')" />
                        <p><strong>${user}</strong>${photo.visibility === 'private' ? ' <i class="fas fa-lock text-gray-500 dark:text-gray-300" title="Private photo"></i>' : ''}</p>
                        <p>${photo.comment || 'No comment'}</p>
                        <p class="text-gray-500 dark:text-gray-400 text-xs">${photo.taken}</p>
                    </div>`;

                const infowindow = new google.maps.InfoWindow({ content: popup });
                marker.addListener("click", () => {
                    infowindow.open(map, marker);
                    google.maps.event.addListenerOnce(infowindow, 'closeclick', () => {
                        if (markers.length > 0) {
                            const newBounds = new google.maps.LatLngBounds();
                            markers.forEach(m => newBounds.extend(m.getPosition()));
                            map.fitBounds(newBounds);
                        }
                    });
                });

                createdMarkers.push(marker);
                bounds.extend(pos);
            });
        });

        clusteredBounds = bounds;

        if (createdMarkers.length > 0) {
            map.fitBounds(clusteredBounds);
            new markerClusterer.MarkerClusterer({
                map,
                markers: createdMarkers,
                renderer: clusterRenderer
            });
        }

        legendList.querySelectorAll('button[data-user]').forEach(btn => {
            btn.addEventListener('click', () => {
                const user = btn.getAttribute('data-user');
                if (activeUsers.has(user)) {
                    activeUsers.delete(user);
                } else {
                    activeUsers.add(user);
                }
                document.querySelector('input[name="legendFilter"][value="all"]').checked = false;

                const allUsers = new Set(allPhotos.map(p => p.user || 'Unknown'));
                document.querySelector('input[name="legendFilter"][value="all"]').checked =
                    allUsers.size === activeUsers.size &&
                    [...allUsers].every(u => activeUsers.has(u));

                renderMarkers();
            });
        });
    }

    

    function showFullscreenImage(src) {
        const modal = document.getElementById('fullscreenImageModal');
        const img = document.getElementById('fullscreenImage');
        if (modal && img) {
            img.src = src;
            modal.classList.remove('hidden');
        }
    }

    function populateCountryDropdown() {
        const countrySet = new Set();
        allPhotos.forEach(p => {
            if (p.country) {
                countrySet.add(p.country);
            }
        });

        const select = document.getElementById('countryFilter');
        if (!select) return;

        select.innerHTML = '<option value="">All Countries</option>';

        [...countrySet].sort().forEach(country => {
            const opt = document.createElement('option');
            opt.value = country;
            opt.textContent = country;
            select.appendChild(opt);
        });

        select.addEventListener('change', () => {
            renderMarkers();
        });
    }

    function closeImageModal() {
        const modal = document.getElementById('fullscreenImageModal');
        const img = document.getElementById('fullscreenImage');
        modal.classList.add('hidden');
        img.src = '';

        // ✅ Log current clusteredBounds info
        if (!map) {
            console.warn('Map not initialized.');
            return;
        }

        if (!clusteredBounds) {
            console.warn('clusteredBounds is null.');
            return;
        }

        if (clusteredBounds.isEmpty()) {
            console.warn('clusteredBounds is empty.');
            return;
        }

        console.log('✅ Re-centering map using clusteredBounds:', clusteredBounds.toString());

        // Force map resize then fit bounds
        setTimeout(() => {
            google.maps.event.trigger(map, 'resize');

            setTimeout(() => {
                map.fitBounds(clusteredBounds);
                console.log('✅ map.fitBounds(clusteredBounds) executed.');
            }, 200);
        }, 200);
    }

</script>
